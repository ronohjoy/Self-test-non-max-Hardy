import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.cm as cm
import scipy.spatial

# Define the function
def tilted_hardy(r, s, t):
    return (r * (1 - r) * s * t * (-1 + r + (1 - r * s) * (1 - r * t))) / ((1 - r * s) * (1 - r * t))

# Parameters
n = 500
pts = []

# Generate 4D points (r, s, t, f)
for i in range(1, n):
    for j in range(1, n):
        for k in range(1, n):
            r = (i / n)
            s = (j / n)
            t = (k / n)
            f = tilted_hardy(r, s, t)  # This creates a 4D point
            pts.append([r, s, t, f])   # Append as a 4D point

# Convert to NumPy array
pts = np.array(pts)

# Compute convex hull in 4D
hull = scipy.spatial.ConvexHull(pts)

# Get convex hull vertices
hull_vertices = pts[hull.vertices]

Reg = hull_vertices[:, :3]

# Extract (r, s, t)
r_vals, s_vals, t_vals = Reg[:, 0], Reg[:, 1], Reg[:, 2]

# Create a figure with 3 subplots
fig, axes = plt.subplots(1, 3, figsize=(10, 3))

# Plot r vs s
axes[0].plot(r_vals, s_vals, 'bx', alpha=0.6)  # 'bo' = blue circles
axes[0].set_xlabel("r")
axes[0].set_ylabel("s")
axes[0].set_title("r vs s")

# Plot s vs t
axes[1].plot(s_vals, t_vals, 'gx', alpha=0.6)
axes[1].set_xlabel("s")
axes[1].set_ylabel("t")
axes[1].set_title("s vs t")

# Plot r vs t
axes[2].plot(r_vals, t_vals, 'rx', alpha=0.6)
axes[2].set_xlabel("r")
axes[2].set_ylabel("t")
axes[2].set_title("r vs t")

# Adjust layout
plt.tight_layout()
plt.show()
